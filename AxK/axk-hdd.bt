// work in progress binary template for 010 editor

typedef struct PARTITION_INFO {
    uint32 start_sector;
    uint32 number_of_sectors;
};

typedef struct SFS_SUPERBLOCK { // 512 byte block
    char yamaha_dev3_tag[11];
    byte unknown_empty_1[117];
    byte partition_type[28]; // hypothesis. logical or physical.

// old:
//        byte logical_physical_content[48]; // indicates whether the partition is logical or physical
// logical:
// 0080h: 00 01 00 00 00 32 00 00 00 00 01 55 1D 84 00 00  .....2.....U.„.. 
// 0090h: 00 00 00 00 00 01 00 00 00 1D 00 00 00 00 02 00  ................ 
// 00A0h: 00 00 08 00 00 00 00 00 00 00 00 03 00 00 07 FD  ...............ý 

// physical: 
// 0080h: A1 E0 01 52 A2 2C 00 00 00 22 00 17 09 10 00 00  ¡à.R¢,..."...... 
// 0090h: 00 00 00 17 09 10 00 00 01 00 01 52 00 00 02 00  ...........R.... 
// 00A0h: 00 00 08 00 00 00 00 00 00 00 00 03 00 00 07 FD  ...............ý 

    uint32 sector_size_bytes;
    uint32 total_number_of_sectors;
    byte unknown_empty_2[4];

    PARTITION_INFO partition_info[8];

    byte unknown_empty_3[280];
};

typedef struct DISC_METADATA_SECTOR { // 512 byte block, not sure yet what this sector is doing exactly...
    byte content_1[8]; // possibly 9 bytes, looks important. like disk size, partition size, checksum, etc...
    byte unknown_empty_3[1];
    byte header[5]; // disk number? partition count?
    byte content_2[12];
    byte name[16];
    byte unknown_empty_4[470];
};

typedef struct PARTITION(uint32 partition_sector_start) { // 1024 byte block
    char yamaha_dev3_tag[11];
    byte unknown_empty_1[53];
    char partition_name[16];
    byte unknown_empty_2[48];
    uint32 content_1 <comment="static">;
    uint32 content_2 <comment="static">;
    byte content_3[8];
    uint32 number_of_clusters; // hypothesis
    uint32 unknown_content_3 <comment="static">; // number of sectors per cluster?
    uint32 unknown_content_4 <comment="static">; // number of clusters for partition clusters?
    uint32 cluster_offset_to_cluster_bitmap;
    local uint32 absolute_sector_cluster_bitmap = partition_sector_start + cluster_offset_to_cluster_bitmap*2;
    uint32 unknown_content_6 <comment="static">; // ???? too big for either clusters or sectors. maybe some magic value. static.
    uint32 cluster_offset_to_directory_index;
    local uint32 absolute_sector_directory_index = partition_sector_start + cluster_offset_to_directory_index*2;
    uint32 unknown_content_8 <comment="static">; // some kind of cluster offset? static
    byte unknown_content_9[88];
    uint32 unknown_content_10a;
    uint32 unknown_content_10b <comment="partition start sector sometimes?">; // the following bytes seem to be shifted sometimes. Hence, this stuff doesn't always match the hypotheses in the comments.
    uint32 unknown_content_11 <comment="sector size?">;
    uint32 unknown_content_12;
    uint32 unknown_content_13 <comment="some kind of absolute sector, a few bytes before sector start">;
    uint32 unknown_content_14;
    uint32 unknown_content_15 <comment="sectors in partition?">;
    uint32 unknown_content_16 <comment="cluster size?">;
    uint32 unknown_content_17;
    byte unknown_content_18[216];
    byte unknown_empty_5[512];
};

typedef struct UNKNOWN_CHUNK_1 {
    byte unknown_empty_1[45];
    byte content_3[4];
    byte unknown_empty_2[975];
};

typedef struct CLUSTER_BITMAP(uint32 bitmap_size) {
    byte used_clusters_bitmap[bitmap_size];
};

enum <uint16> NODE_TYPE {
    NT_INITIAL = 128, // not really INITAL, depending on the image, 128 may appear multiple times in the dir index
    NT_VOLUMES_INDEX = 160,
    NT_EMPTY = 0,
    NT_SMP = 96,
    NT_UNKNOWN_REPEATING_NODE_1 = 64,
    NT_UNKNOWN_SMPL_SBNK_SBAC_SEQU_PROG_NODE = 224,
    NT_SMPL = 23176,
    NT_SBNK = 392
};


typedef struct NODE(uint32 partition_sector_start) { // 72 bytes
    uint16 unknown_1 <comment="usually 1 except for SMPL. SMPL=2. Indicator for oversized data?">;
    uint32 unknown_2a <comment="usually 2 except for SMPL. SMPL=87. Indicator for oversized data?">;
    uint16 unknown_2b;
    NODE_TYPE node_type;
    uint32 cluster_offset;
    local uint32 sector_offset <hidden=true> = cluster_offset*2;
    if (cluster_offset > 0)
        local uint32 absolute_sector = sector_offset + partition_sector_start;
    else
        local uint32 absolute_sector = 0;
    uint32 unknown_2 <comment="usually 2. For the first node node_type=128, it is 1.">;
    uint32 data_size <comment="bytes, 2048 indicator for large dataset? (SMPL)">;
    byte unknown_4[36];
    byte unknown_5[9]; // metadata?
    byte unknown_6;
    byte unknown_7;
    byte unknown_8;
    uint16 unknown_9;
};

struct FILE_INDEX(uint32 partition_sector_start) {
    local uint32 i <hidden=true> = 0;
    local int currentPos <hidden=true>;
    local uint32 next <hidden=true> = 1;
    while ((i < 4) || (next != 0)) {
        currentPos = FTell();
        // we read ahead the next uint32 to determine whether another file is coming as the uint32 block after the last "inode" is zero.
        next = ReadUInt();
        FSeek(currentPos);
        NODE node(partition_sector_start);
        i++;
    }
};


typedef struct UNKNOWN_CHUNK_2 {
    byte unknown[1024]; // very likely wrong: a4k-test-04.hds is longer, dependant on number of volumes or dynamic?
};

typedef struct DYNAMIC_UNKNOWN(uint32 size) {
    byte unknown[size];
};

enum <byte> AXK_OBJECT_TYPE {
    OT_SAMPLE = 16,
    OT_SAMPLE_BANK = 17,
    OT_SEQUENCE = 19,
    OT_PROGRAM = 20
};

typedef struct AXK_SAMPLE_PARAMETER { // 224 bytes (a bit less currently), incomplete
    ubyte reserved_1[24];
    uint32 bitmap_link_to_program_a;
    uint32 bitmap_link_to_program_b;
    uint32 bitmap_link_to_program_c;
    uint32 bitmap_link_to_program_d;
    ubyte bitmap_1;
    ubyte bitmap_2;
    ubyte midi_receive_channel;
    ubyte pitchbend_type;
    ubyte pitchbend_range;
    byte coarse_tune;
    ubyte original_key_left;
    ubyte original_key_right;
    uint16 sampling_frequency_left; 
    uint16 sampling_frequency_right;
    byte finetune_left;
    byte finetune_right;
    int16 reserved_2[2];
    ubyte keyrange_high;
    byte keyrange_low;
    ubyte reserved_3;
    ubyte loop_mode;
    uint16 loop_tempo;
    uint32 wave_start_address_left;
    uint32 wave_start_address_right;
    uint32 wave_length_left;
    uint32 wave_length_right;
    byte start_address_velocity_sensitivity;
    ubyte filter_type;
    ubyte filter_cutoff_frequency;
    ubyte filter_q;
    ubyte cutoff_key_scaling_breakpoint_1;
    ubyte cutoff_key_scaling_breakpoint_2;
    byte cutoff_scaling_level_1;
    byte cutoff_scaling_level_2;
    byte cutoff_velocity_sensititvity;
    byte q_velocity_sensitivity;
    byte detune;
    byte dephase;
    byte expand_width;
    ubyte random_pitch;
    ubyte sample_level;
    byte pan;
    ubyte velocity_low_limit;
    ubyte veloity_offset;
    //...
     
};

typedef struct AXK_SAMPLEBANK_MEMBER { // not sure yet whether this sysex block can be used for the filesystem stuff
    byte assigned_sample_name[16];
    uint32 reserved;
};

typedef struct AXK_COMMON { // 64 byte, not sure yet whether this sysex block can be used for the filesystem stuff
    AXK_OBJECT_TYPE object_type;
    ubyte reserved_1;
    byte name[16];
    ubyte reserved_2[2];
    uint32 size;

    ubyte reserved_3[12];
    byte volume[16];
    ubyte reserved_4[4];

//    ubyte reserved_3[16];
//    ubyte reserved_4[16];


    ubyte reserved_5;
    ubyte reserved_6[3];
    uint32 reserved_7;
};

typedef struct AXK_SAMPLE { // FSFSDEV3SPLXSMPL, work in progress. Does not match the sysex block for some reason
    byte header[16];
    uint32 unknown_1;
    uint32 unknown_2 <comment="some cluster offset">;
    uint32 unknown_3 <comment="some cluster offset">;
//    AXK_COMMON common; // doesn't work!

    uint32 size_left;
    uint32 size_right;
    uint32 unknown_3;
    uint16 samplerate;
    uint16 unknown_4 <comment="num channels?">;
    uint32 unknown_4;
    byte unknown_5;
    byte unknown_6;
    byte linked_wave_object_name[16];
};

typedef struct AXK_SAMPLEBANK { // FSFSDEV3SPLXSBNK, roughly works, incomplete and untested.
    byte header[16];
    uint32 unknown_1;
    uint32 unknown_2 <comment="some cluster offset?">;
    uint32 unknown_3 <comment="some cluster offset?">;
    uint32 unknown_4;
    ubyte unknown_empty_5[16];
    // common alike?
    AXK_OBJECT_TYPE object_type;
    ubyte unknown_6;
    byte name[16]; // or assigned sample name? from sample bank member?
    uint16 unknown_6;
    uint32 size; // really?
    // ???
    uint16 unknown_7;
    uint16 unknown_8 <comment="possibly two bytes?">;
    byte unknown_empty_9[8];
    byte assigned_volume[16];
    ubyte unknown_9;
    byte unknown_empty_10[7];
    byte sample_type[4] <comment="usually SMPX?">;
    byte unknown_empty_11[8];
    // sample bulk data alike?
    byte linked_wave_object_name_left[16];
    byte linked_wave_object_name_right[16];
    uint16 unknown_13;
    uint16 unknown_14;
    byte unknown_empty_15[4];
    uint16 unknown_16;
    uint16 unknown_17;
    byte unknown_empty_18[4];
    // sample parameter (alike)?
    AXK_SAMPLE_PARAMETER sample_parameter;
};

// -----------------------------------------------------------------------------------------------------

BigEndian();

local int sectorCount <hidden=true>;
sectorCount = 0;

SetBackColor( cLtYellow );
SFS_SUPERBLOCK sfs_superblock;
sectorCount++;

SetBackColor( cLtGreen );
SFS_SUPERBLOCK sfs_superblock_backup <hidden=true>;
sectorCount++;

SetBackColor( cLtYellow );
DISC_METADATA_SECTOR disc_metadata_sector;
sectorCount++;

local int i <hidden=true>;
local uint32 start_sector <hidden=true>;
local uint32 bytes_to_skip <hidden=true>;
local uint32 bitmap_size <hidden=true>;
bitmap_size = 0;
for (i=0; i < 8; i++) {
    if (sfs_superblock.partition_info[i].number_of_sectors <= 0)
        continue;
    start_sector = sfs_superblock.partition_info[i].start_sector;
    bytes_to_skip = start_sector*512-(sectorCount*512);
    if (bytes_to_skip > 0) {
        DYNAMIC_UNKNOWN unknown_chunk(bytes_to_skip) <hidden=true>;
        sectorCount+=start_sector-sectorCount;
    }
    SetBackColor( cLtPurple );
    PARTITION partition(sfs_superblock.partition_info[i].start_sector);
    sectorCount+=2;
    PARTITION partition_backup(sfs_superblock.partition_info[i].start_sector) <hidden=true>;
    sectorCount+=2;

// direct cluster bitmap size
    bitmap_size = partition.cluster_offset_to_directory_index - partition.cluster_offset_to_cluster_bitmap;

    CLUSTER_BITMAP used_clusters(bitmap_size*2*512);
    sectorCount+=bitmap_size*2;
    CLUSTER_BITMAP used_clusters_backup(bitmap_size*1024) <hidden=true>;
    sectorCount+=bitmap_size*2;

// file/directory index
    FILE_INDEX file_index(sfs_superblock.partition_info[i].start_sector);
    sectorCount+=2; // we currently assume the file index is two sectors. This likely needs to be dynamic somehow.

// try to parse the data blocks
    local int currentPos <hidden=true> = FTell();

    local int j <hidden=true>;
    local uint32 data_sector <hidden=true>;
    for (j=0; j < 12; j++) {
        if (file_index.node[j].data_size > 0) {
            data_sector = file_index.node[j].absolute_sector;
            
            FSeek(data_sector*512);
            
            if (file_index.node[j].node_type == NT_SBNK) {
                AXK_SAMPLEBANK samplebank;
                continue;
            } 
            if ((file_index.node[j].node_type == NT_SMPL))  {
                AXK_SAMPLE sample;
                continue;
            }

// generic parsing to unknown data structure
//           local DYNAMIC_UNKNOWN node_data(directory_index.node[j].data_size);
//           ReadBytes(node_data.unknown, data_sector*512, directory_index.node[j].data_size);

        }
    }    
    FSeek(currentPos);

}

