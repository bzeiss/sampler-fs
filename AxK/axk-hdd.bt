// work in progress binary template for 010 editor

typedef struct PARTITION_INFO {
    uint32 start_sector;
    uint32 number_of_sectors;
};

typedef struct SFS_SUPERBLOCK { // 512 byte block
    char yamaha_dev3_tag[11];
    byte unknown_empty_1[117];
    byte partition_type[28]; // hypothesis. logical or physical.

// old:
//        byte logical_physical_content[48]; // indicates whether the partition is logical or physical
// logical:
// 0080h: 00 01 00 00 00 32 00 00 00 00 01 55 1D 84 00 00  .....2.....U.„.. 
// 0090h: 00 00 00 00 00 01 00 00 00 1D 00 00 00 00 02 00  ................ 
// 00A0h: 00 00 08 00 00 00 00 00 00 00 00 03 00 00 07 FD  ...............ý 

// physical: 
// 0080h: A1 E0 01 52 A2 2C 00 00 00 22 00 17 09 10 00 00  ¡à.R¢,..."...... 
// 0090h: 00 00 00 17 09 10 00 00 01 00 01 52 00 00 02 00  ...........R.... 
// 00A0h: 00 00 08 00 00 00 00 00 00 00 00 03 00 00 07 FD  ...............ý 

    uint32 sector_size_bytes;
    uint32 total_number_of_sectors;
    byte unknown_content_5[4];

    PARTITION_INFO partition_info[8];

    byte unknown_empty_2[280];
};

typedef struct DISC_METADATA_SECTOR { // 512 byte block
    byte content_1[8]; // possibly 9 bytes, looks important. like disk size, partition size, checksum, etc...
    byte unknown_empty_3[1];
    byte header[5]; // disk number? partition count?
    byte content_2[12];
    byte name[16];
    byte unknown_empty_4[470];
};

typedef struct PARTITION(uint32 partition_sector_start) { // 1024 byte block
    char yamaha_dev3_tag[11];
    byte unknown_empty_1[53];
    char partition_name[16];
    byte unknown_empty_2[48];
    byte content_1[16];
    uint32 number_of_clusters; // hypothesis
    uint32 unknown_content_3 <comment="static">; // number of sectors per cluster?
    uint32 unknown_content_4 <comment="static">; // number of clusters for partition clusters?
    uint32 cluster_offset_to_cluster_bitmap;
    local uint32 absolute_sector_cluster_bitmap = partition_sector_start + cluster_offset_to_cluster_bitmap*2;
    uint32 unknown_content_6 <comment="static">; // ???? too big for either clusters or sectors. maybe some magic value. static.
    uint32 cluster_offset_to_directory_index;
    local uint32 absolute_sector_directory_index = partition_sector_start + cluster_offset_to_directory_index*2;
    uint32 unknown_content_8 <comment="static">; // some kind of cluster offset? static
    byte unknown_content_9[88];
    uint32 unknown_content_10a;
    uint32 unknown_content_10b <comment="partition start sector sometimes?">; // the following bytes seem to be shifted sometimes. Hence, this stuff doesn't always match the hypotheses in the comments.
    uint32 unknown_content_11 <comment="sector size?">;
    uint32 unknown_content_12;
    uint32 unknown_content_13 <comment="some kind of absolute sector, a few bytes before sector start">;
    uint32 unknown_content_14;
    uint32 unknown_content_15 <comment="sectors in partition?">;
    uint32 unknown_content_16 <comment="cluster size?">;
    uint32 unknown_content_17;
    byte unknown_content_18[216];
    byte unknown_empty_5[512];
};

typedef struct UNKNOWN_CHUNK_1 {
    byte unknown_empty_1[45];
    byte content_3[4];
    byte unknown_empty_2[975];
};

typedef struct CLUSTER_BITMAP(uint32 bitmap_size) {
    byte used_clusters_bitmap[bitmap_size];
};

enum <uint16> NODE_TYPE {
    INITIAL = 128,
    VOLUMES_INDEX = 160,
    EMPTY = 0,
    SMP = 96,
    UNKNOWN_REPEATING_NODE_1 = 64,
    UNKNOWN_SMPL_SBNK_SBAC_SEQU_PROG_NODE = 224,
    SMPX = 23176,
    SBNK = 394
};


typedef struct NODE(uint32 partition_sector_start) { // 72 bytes
    uint16 unknown_1;
    uint32 unknown_2a;
    uint16 unknown_2b;
    NODE_TYPE node_type;
    uint32 cluster_offset;
    local uint32 sector_offset <hidden=true> = cluster_offset*2;
    if (cluster_offset > 0)
        local uint32 absolute_sector = sector_offset + partition_sector_start;
    else
        local uint32 absolute_sector = 0;
    uint32 unknown_2;
    uint32 unknown_3;
    byte unknown_4[36];
    byte unknown_5[9]; // metadata?
    byte unknown_6;
    byte unknown_7;
    byte unknown_8;
    uint16 unknown_9;
};

typedef struct DIRECTORY_INDEX(uint32 partition_sector_start) { // currently hardcoded to 1024 bytes. Must be dynamic.
    NODE node(partition_sector_start)[11] <optimize=false>; // the first three nodes seem to be predefined
    byte sector_filler[232];
};

typedef struct UNKNOWN_CHUNK_2 {
    byte unknown[1024]; // very likely wrong: a4k-test-04.hds is longer, dependant on number of volumes or dynamic?
};

typedef struct DYNAMIC_UNKNOWN(uint32 size) {
    byte unknown[size];
};

/*
typedef struct SAMPLE {
    byte header[16]; // FSFSDEV3SPLXSMPL
    uint32 sector_size;
    uint32 unknown_1; // 3?
    uint32 unknown_2; // 124?
    uint32 sample_length_1; // left?
    uint32 sample_length_2; // right?
    byte unknown_3[14];
    byte sample_name_internal[16];
};

typedef struct SAMPLEBANK {
    byte header[16]; // FSFSDEV3SPLXSBNK
    byte unknown_1[34];
    byte sample_bank_name[16];

};
*/

// -----------------------------------------------------------------------------------------------------

BigEndian();

local int sectorCount <hidden=true>;
sectorCount = 0;

SetBackColor( cLtYellow );
SFS_SUPERBLOCK sfs_superblock;
sectorCount++;

SetBackColor( cLtGreen );
SFS_SUPERBLOCK sfs_superblock_backup <hidden=true>;
sectorCount++;

SetBackColor( cLtYellow );
DISC_METADATA_SECTOR disc_metadata_sector;
sectorCount++;

local int i <hidden=true>;
local uint32 start_sector <hidden=true>;
local uint32 bytes_to_skip <hidden=true>;
local uint32 bitmap_size <hidden=true>;
bitmap_size = 0;
for (i=0; i < 8; i++) {
    if (sfs_superblock.partition_info[i].number_of_sectors <= 0)
        continue;
    start_sector = sfs_superblock.partition_info[i].start_sector;
    bytes_to_skip = start_sector*512-(sectorCount*512);
    if (bytes_to_skip > 0) {
        DYNAMIC_UNKNOWN unknown_chunk(bytes_to_skip) <hidden=true>;
        sectorCount+=start_sector-sectorCount;
    }
    SetBackColor( cLtPurple );
    PARTITION partition(sfs_superblock.partition_info[i].start_sector);
    sectorCount+=2;
    PARTITION partition_backup(sfs_superblock.partition_info[i].start_sector) <hidden=true>;
    sectorCount+=2;

// calculated cluster bitmap size
//    bitmap_size = partition.number_of_clusters;
//    bitmap_size = Abs((bitmap_size / 8.0)+0.5);
//    bitmap_size = Ceil(bitmap_size/1024.0);
//    CLUSTER_BITMAP used_clusters(bitmap_size*1024);
//    sectorCount+=bitmap_size*2;
//    CLUSTER_BITMAP used_clusters_backup(bitmap_size*1024);
//    sectorCount+=bitmap_size*2;


// direct cluster bitmap size
    bitmap_size = partition.cluster_offset_to_directory_index - partition.cluster_offset_to_cluster_bitmap;

    CLUSTER_BITMAP used_clusters(bitmap_size*2*512);
    sectorCount+=bitmap_size*2;
    CLUSTER_BITMAP used_clusters_backup(bitmap_size*1024) <hidden=true>;
    sectorCount+=bitmap_size*2;

    DIRECTORY_INDEX directory_index(sfs_superblock.partition_info[i].start_sector);
    sectorCount+=2;
}

