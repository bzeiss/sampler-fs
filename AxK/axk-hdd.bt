// work in progress binary template for 010 editor

typedef struct PARTITION_INFO {
    uint32 start_sector;
    uint32 number_of_sectors;
};

typedef struct SFS_SUPERBLOCK { // 512 byte block
    char yamaha_dev3_tag[11];
    byte unknown_empty_1[117];
    byte partition_type[28]; // hypothesis. logical or physical.

// old:
//        byte logical_physical_content[48]; // indicates whether the partition is logical or physical
// logical:
// 0080h: 00 01 00 00 00 32 00 00 00 00 01 55 1D 84 00 00  .....2.....U.„.. 
// 0090h: 00 00 00 00 00 01 00 00 00 1D 00 00 00 00 02 00  ................ 
// 00A0h: 00 00 08 00 00 00 00 00 00 00 00 03 00 00 07 FD  ...............ý 

// physical: 
// 0080h: A1 E0 01 52 A2 2C 00 00 00 22 00 17 09 10 00 00  ¡à.R¢,..."...... 
// 0090h: 00 00 00 17 09 10 00 00 01 00 01 52 00 00 02 00  ...........R.... 
// 00A0h: 00 00 08 00 00 00 00 00 00 00 00 03 00 00 07 FD  ...............ý 

    uint32 sector_size_bytes;
    uint32 total_number_of_sectors;
    byte unknown_content_5[4];

    PARTITION_INFO partition_info[8];

    byte unknown_empty_2[280];
};

typedef struct DISC_METADATA_SECTOR { // 512 byte block
    byte content_1[8]; // possibly 9 bytes, looks important. like disk size, partition size, checksum, etc...
    byte unknown_empty_3[1];
    byte header[5]; // disk number? partition count?
    byte content_2[12];
    byte name[16];
    byte unknown_empty_4[470];
};

typedef struct PARTITION { // 1024 byte block
    char yamaha_dev3_tag[11];
    byte unknown_empty_1[53];
    char partition_name[16];
    byte unknown_empty_2[48];
    byte content_1[16];
    uint32 number_of_clusters; // hypothesis
    uint32 unknown_content_3; // number of sectors per cluster?
    uint32 unknown_content_4; // number of clusters for partition clusters?
    uint32 unknown_content_5; // cluster bitmap cluster size + number of clusters for partition clusters? dynamic.
    uint32 unknown_content_6; // ???? too big for either clusters or sectors. maybe some magic value. static.
    uint32 unknown_content_7; // directory map size? dynamic.
    uint32 unknown_content_8; // some kind of cluster offset? static
    byte unknown_content_9[340];
    byte unknown_empty_5[512];
};

typedef struct UNKNOWN_CHUNK_1 {
    byte unknown_empty_1[45];
    byte content_3[4];
    byte unknown_empty_2[975];
};

typedef struct CLUSTER_BITMAP(uint32 bitmap_size) {
    byte used_clusters_bitmap[bitmap_size];
};

typedef struct UNKNOWN_CHUNK_2 {
    byte unknown[1024]; // very likely wrong: a4k-test-04.hds is longer, dependant on number of volumes or dynamic?
};

typedef struct DYNAMIC_UNKNOWN(uint32 size) {
    byte unknown[size];
};

/*
typedef struct SAMPLE {
    byte header[16]; // FSFSDEV3SPLXSMPL
    uint32 sector_size;
    uint32 unknown_1; // 3?
    uint32 unknown_2; // 124?
    uint32 sample_length_1; // left?
    uint32 sample_length_2; // right?
    byte unknown_3[14];
    byte sample_name_internal[16];
};

typedef struct SAMPLEBANK {
    byte header[16]; // FSFSDEV3SPLXSBNK
    byte unknown_1[34];
    byte sample_bank_name[16];

};
*/

// -----------------------------------------------------------------------------------------------------

BigEndian();

local int sectorCount;
sectorCount = 0;

SetBackColor( cLtYellow );
SFS_SUPERBLOCK sfs_superblock;
sectorCount++;

SetBackColor( cLtGreen );
SFS_SUPERBLOCK sfs_superblock_backup;
sectorCount++;

SetBackColor( cLtYellow );
DISC_METADATA_SECTOR disc_metadata_sector;
sectorCount++;

local int i;
local uint32 start_sector;
local uint32 bytes_to_skip;
local uint32 bitmap_size;
bitmap_size = 0;
for (i=0; i < 8; i++) {
    if (sfs_superblock.partition_info[i].number_of_sectors <= 0)
        continue;
    start_sector = sfs_superblock.partition_info[i].start_sector;
    bytes_to_skip = start_sector*512-(sectorCount*512);
    if (bytes_to_skip > 0) {
        DYNAMIC_UNKNOWN unknown_chunk(bytes_to_skip);
        sectorCount+=start_sector-sectorCount;
    }
    SetBackColor( cLtPurple );
    PARTITION partition;
    sectorCount+=2;
    PARTITION partition_backup;
    sectorCount+=2;

// calculated cluster bitmap size
//    bitmap_size = partition.number_of_clusters;
//    bitmap_size = Abs((bitmap_size / 8.0)+0.5);
//    bitmap_size = Ceil(bitmap_size/1024.0);
//    CLUSTER_BITMAP used_clusters(bitmap_size*1024);
//    sectorCount+=bitmap_size*2;
//    CLUSTER_BITMAP used_clusters_backup(bitmap_size*1024);
//    sectorCount+=bitmap_size*2;


// direct cluster bitmap size
    bitmap_size = partition.unknown_content_5-partition.unknown_content_4;

    CLUSTER_BITMAP used_clusters(bitmap_size*2*512);
    sectorCount+=bitmap_size*2;
    CLUSTER_BITMAP used_clusters_backup(bitmap_size*1024);
    sectorCount+=bitmap_size*2;
}

